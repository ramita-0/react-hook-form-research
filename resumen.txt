Primero que nada explicar componentes controlados y no controlados


Componentes controlados

Son componentes que reciben un valor y handler por prop, de manera que, el estado y su valor estan en sincronia
es decir, cuando el input dispare el onChange, su valor en el estado cambiara, por lo que se modificara, y este estado modificado
sera vuelto a pasar por props. 

function ControlledForm() {
	const [state, setState] = useState({
    nombre: "",
    apellido: ""
  })

  const handleChangeState = (field, value) => {
    setState(prevState => ({...state, [field]: value}))
  }

  useEffect(() => {console.log("Re-render!")}, [state])
  
  return (
    <div>

      <h1>Ingrese su nombre</h1>
      <input type="text" value={state.nombre} onChange={e => handleChangeState("nombre", e.target.value)} />

      <h1>Ingrese su apellido</h1>
      <input type="text" value={state.apellido} onChange={e => handleChangeState("apellido", e.target.value)} />

      <button onClick={e => console.log(state)}>Submit</button>
      
    </div>
  );
}


Podemos observar que al modificar cualquiera de los dos campos, se re renderea todo el tiempo el estado, de manera innecesaria ya que a mi
me importa el estado final, no el transicional. Ejemplo:

  R, Ra, Ram, Rami, Ramir, Ramiro

En esta secuencia, hubieron 6 re-renders, cuando a mi me importa solo el estado cuando yo clickeo Submit

Sabiendo esto, ahora podemos ver los no controlados


function UncontrolledForm() {
  const [state, setState] = useState("")

  const handleSubmitClick = () => {
    const name = window.inputReference.value;
    setState(prevState => name)
  };

  useEffect(() => {console.log("Re-render!")}, [state])

  return (
    <div>
      <input type="text" id="inputReference" />
      <button onClick={e => handleSubmitClick()}>Submit</button>
    </div>
  );
}

En este caso, fijense que el input no tiene ni handler ni value, tiene un id, el cual identifica este nodo en el DOM.
Uno al modificar este campo, esta modificando el innerHTML del nodo, por lo que para luego acceder al valor de este nodo, habria que acceder a su valor en el DOM.
En este caso lo codee de manera que uso el objeto window, en el proximo ejemplo lo hago de la "manera" React


function UncontrolledForm() {
  const [state, setState] = useState("")
  const nameRef = useRef();


  const handleSubmitClick = () => {
    setState(prevState => nameRef.current.value)
  }

  useEffect(() => {console.log("Re-render!")}, [state])

  return (
    <div>
      <input type="text" ref={nameRef} />
      <button onClick={e => handleSubmitClick()} />
    </div>
  );
}


En este ejemplo doy uso del hook useRef() para instanciar una referencia que va a ser asignada al input
la cual despues accedo a su valor para setear el estado al hacer click en el submit



Pros generales:
  - Open source
  - Buen DX y UX
  - Activamente mantenido
  - Facil de incorporar a formularios existentes, modificando poco codigo 
  - En alza de popularidad
  - Liviano y performante
  - Tiene validacion estandar de HTML
  - Se basa en componentes no controlados, aislando los inputs de tu formulario entre si.
  - DevTools para debugging
Pros casos de uso:
  - Puedo encapsular componentes de librerias de ui que son controlados con el componente Controller y hacerlo funcionar. 
    Por lo que podemos tener componentes controlados y no controlados sin problema alguno
  - Se puede utilizar en formularios anidados
  - Soporte para Zod, Yup y demas
  - Soporta la implementacion con componentes de clase, pero es mas complejo
  - Soporte para forms para personas con imparidades (A11y, ARIA)
  - Wizzards

Casos de uso a entender como se desarrollan con el hook:
  - Array de objetos/plano que yo agrega o saco elementos del mismo, que pase su valor final, ej: [1,2,3,4] a ser parte del estado del formulario al submitearlo.
    El mismo array se modifica por medio de un solo input, que yo escribo y al darle al boton + se agrega, o al clickear una X en uno de los elementos rendereados, se borra del
    estado.
  - Array de CAMPOS dinamicos, ej: tabla de despachos TAGSA. (useFieldArray?) (Las filas de la tabla son "dinamicas" por API, no por input del usuario)

Hooks:
  useForm
    - Hook principal, encargado de almacenar los datos del formulario

  useController
    - Misma funcionalidad que <Controller />, solo que con el hook, podemos crear componentes controlados reutilizables

  useFormContext
    - Similar al context de react, utilizando un componente proveedor FormProvider se puede llamar a todos los metodos del useForm, dentro de los componentes hijos del proveedor

  useWatch
    - Se subscribe a el/los inputs solicitados pudiendo realizar conditional renderings al ver en "vivo" su contenido

  useFormState
    - Sirve para detectar si el usuario modifico el campo, dejandolo "dirty", re-renderea a nivel raiz

  useFieldArray
    - Utilizado cuando tenemos campos dinamicos, que el usuario puedo agregar, borrar, moverlos, etc. Viene con su set de metodos, ej: append, prepend, remove...

Metodos de useForm:
  register:
    - Registra un input al formulario, se le puede agregar validacion HTML nativa y custom
  unregister:
    - Da de baja el registro de un campo del formulario
  formState:
    - Mismo funcionamiento que useFormState pero re-renderea a nivel raiz
  watch:
    - Mismo funcionamiento que useWatch pero re-rendea a nivel raiz
  handleSubmit:
    - Recive los datos del form, si es que la validation es satisfactoria
  reset:
    - Sirve para resetear todo el estado del formulario, las subscripciones y referencias de campos. Usando ciertos argumentos, el reseteo puede hacerse parcialmente.
  resetField:
    - Resetea el estado de un solo campo
  setError:
    - Permite manualmente setear uno o mas errores a campos del formulario
  clearErrors:
    - Permite borrar manualmente errores en el formulario
  setValue:
    - Permite cambiar el valor de un campo a lo que se quiera, al cambiarlo tambien se puede validar esta insercion
  setFocus:
    - Focusea un input a eleccion
  getValues:
    - Lee el/los valores del form
  getFieldState:
    - Devuelve el estado de un campo; si se modifico (dirty), se toco (focus, blur), etc.
  trigger:
    - Triggerea manualmente validacion de input o form, es util cuando tenemos dependencia de validacion (el valor de un input depende del valor de otro input)
  control:
    - Registra componentes en el formulario (entiendo que se usa para los componentes controlados? que necesitan de este metodo por no poder usar el register?)
  Form (BETA):
    - ...
    
Componentes:
  Controller:
    - Esta libreria, recae en el uso de los componentes no controlados. A dia de hoy es complicado no utilizar una libreria de UI, que, generalmente, utilizan componentes controlados
      por lo que este componente nos permite envolver al componente de UI y permitirnos trabajar con el, integrandolo al formulario
      
      Un caso de uso para <Controller /> Seria cuando queremos
      implementar rapidamente un componente controlado, y lo envolvemos con este Controller.



watch vs getValues

Watch: Subscribirse o "mirar" el input, es decir, se re renderea el componente al que te subscribis, cuando este mismo cambia por un evento.
getValues: devuelve una instancia de el/los valores indicados, los cuales estan almacenados dentro del hook. Es rapido y no re-renderea.



Parseador en casos de 0, undefined, null:

const ControllerPlus = ({
  control,
  transform,
  name,
  defaultValue
}) => (
  <Controller
    defaultValue={defaultValue}
    control={control}
    name={name}
    render={({ field }) => (
      <input
        onChange={(e) => field.onChange(transform.output(e))}
        value={transform.input(field.value)}
      />
    )}
  />
);

// usage below:
<ControllerPlus<string, number>
  transform={{
    input: (value) =>
      isNaN(value) || value === 0 ? "" : value.toString(),
    output: (e) => {
      const output = parseInt(e.target.value, 10);
      return isNaN(output) ? 0 : output;
    }
  }}
  control={control}
  name="number"
  defaultValue=""
/>

